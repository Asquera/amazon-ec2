Index: lib/EC2/responses.rb
===================================================================
--- lib/EC2/responses.rb	(revision 7)
+++ lib/EC2/responses.rb	(working copy)
@@ -32,11 +32,11 @@
     end
     
     def parse_error
-      doc = Document.new(@http_xml)
-      element = XPath.first(doc, ERROR_XPATH)
+      doc = REXML::Document.new(@http_xml)
+      element = REXML::XPath.first(doc, ERROR_XPATH)
       
-      errorCode = XPath.first(element, "Code").text
-      errorMessage = XPath.first(element, "Message").text
+      errorCode = REXML::XPath.first(element, "Code").text
+      errorMessage = REXML::XPath.first(element, "Message").text
       
       [["#{errorCode}: #{errorMessage}"]]
     end
@@ -58,15 +58,15 @@
   class DescribeImagesResponse < Response
     ELEMENT_XPATH = "DescribeImagesResponse/imagesSet/item"
     def parse
-      doc = Document.new(@http_xml)
+      doc = REXML::Document.new(@http_xml)
       lines = []
       
       doc.elements.each(ELEMENT_XPATH) do |element|
-        imageId = XPath.first(element, "imageId").text
-        imageLocation = XPath.first(element, "imageLocation").text
-        imageOwnerId = XPath.first(element, "imageOwnerId").text
-        imageState = XPath.first(element, "imageState").text
-        isPublic = XPath.first(element, "isPublic").text
+        imageId = REXML::XPath.first(element, "imageId").text
+        imageLocation = REXML::XPath.first(element, "imageLocation").text
+        imageOwnerId = REXML::XPath.first(element, "imageOwnerId").text
+        imageState = REXML::XPath.first(element, "imageState").text
+        isPublic = REXML::XPath.first(element, "isPublic").text
         lines << ["IMAGE", imageId, imageLocation, imageOwnerId, imageState, isPublic]
       end
       lines
@@ -77,8 +77,8 @@
   class RegisterImageResponse < Response
     ELEMENT_XPATH = "RegisterImageResponse/imageId"
     def parse
-      doc = Document.new(@http_xml)
-      lines = [["IMAGE", XPath.first(doc, ELEMENT_XPATH).text]]
+      doc = REXML::Document.new(@http_xml)
+      lines = [["IMAGE", REXML::XPath.first(doc, ELEMENT_XPATH).text]]
     end
   end
   
@@ -94,12 +94,12 @@
   class CreateKeyPairResponse < Response
     ELEMENT_XPATH = "CreateKeyPairResponse"
     def parse
-      doc = Document.new(@http_xml)
-      element = XPath.first(doc, ELEMENT_XPATH)
+      doc = REXML::Document.new(@http_xml)
+      element = REXML::XPath.first(doc, ELEMENT_XPATH)
       
-      keyName = XPath.first(element, "keyName").text
-      keyFingerprint = XPath.first(element, "keyFingerprint").text
-      keyMaterial = XPath.first(element, "keyMaterial").text
+      keyName = REXML::XPath.first(element, "keyName").text
+      keyFingerprint = REXML::XPath.first(element, "keyFingerprint").text
+      keyMaterial = REXML::XPath.first(element, "keyMaterial").text
       
       line = [["KEYPAIR", keyName, keyFingerprint], [keyMaterial]]
     end
@@ -109,12 +109,12 @@
   class DescribeKeyPairsResponse < Response
     ELEMENT_XPATH = "DescribeKeyPairsResponse/keySet/item"
     def parse
-      doc = Document.new(@http_xml)
+      doc = REXML::Document.new(@http_xml)
       lines = []
   
       doc.elements.each(ELEMENT_XPATH) do |element|
-        keyName = XPath.first(element, "keyName").text
-        keyFingerprint = XPath.first(element, "keyFingerprint").text
+        keyName = REXML::XPath.first(element, "keyName").text
+        keyFingerprint = REXML::XPath.first(element, "keyFingerprint").text
         lines << ["KEYPAIR", keyName, keyFingerprint]
       end
       lines
@@ -133,13 +133,13 @@
   class RunInstancesResponse < Response
     ELEMENT_XPATH = "RunInstancesResponse"
     def parse
-      doc = Document.new(@http_xml)
+      doc = REXML::Document.new(@http_xml)
       lines = []
       
-      rootelement = XPath.first(doc, ELEMENT_XPATH)
+      rootelement = REXML::XPath.first(doc, ELEMENT_XPATH)
       
-      reservationId = XPath.first(rootelement, "reservationId").text
-      ownerId = XPath.first(rootelement, "ownerId").text
+      reservationId = REXML::XPath.first(rootelement, "reservationId").text
+      ownerId = REXML::XPath.first(rootelement, "ownerId").text
       groups = nil
       rootelement.elements.each("groupSet/item/groupId") do |element|
         if not groups
@@ -150,16 +150,16 @@
       end
       lines << ["RESERVATION", reservationId, ownerId, groups]
       
-      #    rootelement = XPath.first(doc, ELEMENT_XPATH)
+      #    rootelement = REXML::XPath.first(doc, ELEMENT_XPATH)
       rootelement.elements.each("instancesSet/item") do |element|
-        instanceId = XPath.first(element, "instanceId").text
-        imageId = XPath.first(element, "imageId").text
-        instanceState = XPath.first(element, "instanceState/name").text
+        instanceId = REXML::XPath.first(element, "instanceId").text
+        imageId = REXML::XPath.first(element, "imageId").text
+        instanceState = REXML::XPath.first(element, "instanceState/name").text
         # Only for debug mode, which we don't support yet:
-        instanceStateCode = XPath.first(element, "instanceState/code").text
-        dnsName = XPath.first(element, "dnsName").text
+        instanceStateCode = REXML::XPath.first(element, "instanceState/code").text
+        dnsName = REXML::XPath.first(element, "dnsName").text
         # We don't return this, but still:
-        reason = XPath.first(element, "reason").text
+        reason = REXML::XPath.first(element, "reason").text
         lines << ["INSTANCE", instanceId, imageId, dnsName, instanceState]
       end
       lines
@@ -170,12 +170,12 @@
   class DescribeInstancesResponse < Response
     ELEMENT_XPATH = "DescribeInstancesResponse/reservationSet/item"
     def parse
-      doc = Document.new(@http_xml)
+      doc = REXML::Document.new(@http_xml)
       lines = []
       
       doc.elements.each(ELEMENT_XPATH) do |rootelement|
-        reservationId = XPath.first(rootelement, "reservationId").text
-        ownerId = XPath.first(rootelement, "ownerId").text
+        reservationId = REXML::XPath.first(rootelement, "reservationId").text
+        ownerId = REXML::XPath.first(rootelement, "ownerId").text
         groups = nil
         rootelement.elements.each("groupSet/item/groupId") do |element|
           if not groups
@@ -187,14 +187,14 @@
         lines << ["RESERVATION", reservationId, ownerId, groups]
         
         rootelement.elements.each("instancesSet/item") do |element|
-          instanceId = XPath.first(element, "instanceId").text
-          imageId = XPath.first(element, "imageId").text
-          instanceState = XPath.first(element, "instanceState/name").text
+          instanceId = REXML::XPath.first(element, "instanceId").text
+          imageId = REXML::XPath.first(element, "imageId").text
+          instanceState = REXML::XPath.first(element, "instanceState/name").text
           # Only for debug mode, which we don't support yet:
-          instanceStateCode = XPath.first(element, "instanceState/code").text
-          dnsName = XPath.first(element, "dnsName").text
+          instanceStateCode = REXML::XPath.first(element, "instanceState/code").text
+          dnsName = REXML::XPath.first(element, "dnsName").text
           # We don't return this, but still:
-          reason = XPath.first(element, "reason").text
+          reason = REXML::XPath.first(element, "reason").text
           lines << ["INSTANCE", instanceId, imageId, dnsName, instanceState]
         end
       end
@@ -206,17 +206,17 @@
   class TerminateInstancesResponse < Response
     ELEMENT_XPATH = "TerminateInstancesResponse/instancesSet/item"
     def parse
-      doc = Document.new(@http_xml)
+      doc = REXML::Document.new(@http_xml)
       lines = []
       
       doc.elements.each(ELEMENT_XPATH) do |element|
-        instanceId = XPath.first(element, "instanceId").text
-        shutdownState = XPath.first(element, "shutdownState/name").text
+        instanceId = REXML::XPath.first(element, "instanceId").text
+        shutdownState = REXML::XPath.first(element, "shutdownState/name").text
         # Only for debug mode, which we don't support yet:
-        shutdownStateCode = XPath.first(element, "shutdownState/code").text
-        previousState = XPath.first(element, "previousState/name").text
+        shutdownStateCode = REXML::XPath.first(element, "shutdownState/code").text
+        previousState = REXML::XPath.first(element, "previousState/name").text
         # Only for debug mode, which we don't support yet:
-        previousStateCode = XPath.first(element, "previousState/code").text
+        previousStateCode = REXML::XPath.first(element, "previousState/code").text
         lines << ["INSTANCE", instanceId, previousState, shutdownState]
       end
       lines
@@ -235,18 +235,18 @@
   class DescribeSecurityGroupsResponse < Response
     ELEMENT_XPATH = "DescribeSecurityGroupsResponse/securityGroupInfo/item"
     def parse
-      doc = Document.new(@http_xml)
+      doc = REXML::Document.new(@http_xml)
       lines = []
       
       doc.elements.each(ELEMENT_XPATH) do |rootelement|
-        groupName = XPath.first(rootelement, "groupName").text
-        ownerId = XPath.first(rootelement, "ownerId").text
-        groupDescription = XPath.first(rootelement, "groupDescription").text
+        groupName = REXML::XPath.first(rootelement, "groupName").text
+        ownerId = REXML::XPath.first(rootelement, "ownerId").text
+        groupDescription = REXML::XPath.first(rootelement, "groupDescription").text
         lines << ["GROUP", ownerId, groupName, groupDescription]
         rootelement.elements.each("ipPermissions/item") do |element|
-          ipProtocol = XPath.first(element, "ipProtocol").text
-          fromPort = XPath.first(element, "fromPort").text
-          toPort = XPath.first(element, "toPort").text
+          ipProtocol = REXML::XPath.first(element, "ipProtocol").text
+          fromPort = REXML::XPath.first(element, "fromPort").text
+          toPort = REXML::XPath.first(element, "toPort").text
           permArr = [
                      "PERMISSION",
                      ownerId,
@@ -258,12 +258,12 @@
                      "FROM"
                     ]
           element.elements.each("groups/item") do |subelement|
-            userId = XPath.first(subelement, "userId").text
-            targetGroupName = XPath.first(subelement, "groupName").text
+            userId = REXML::XPath.first(subelement, "userId").text
+            targetGroupName = REXML::XPath.first(subelement, "groupName").text
             lines << permArr + ["USER", userId, "GRPNAME", targetGroupName]
           end
           element.elements.each("ipRanges/item") do |subelement|
-            cidrIp = XPath.first(subelement, "cidrIp").text
+            cidrIp = REXML::XPath.first(subelement, "cidrIp").text
             lines << permArr + ["CIDR", cidrIp]
           end
         end
@@ -316,11 +316,11 @@
   class DescribeImageAttributeResponse < Response
     ELEMENT_XPATH = "DescribeImageAttributeResponse"
     def parse
-      doc = Document.new(@http_xml)
+      doc = REXML::Document.new(@http_xml)
       lines = []
       
-      rootelement = XPath.first(doc, ELEMENT_XPATH)
-      imageId = XPath.first(rootelement, "imageId").text
+      rootelement = REXML::XPath.first(doc, ELEMENT_XPATH)
+      imageId = REXML::XPath.first(rootelement, "imageId").text
       
       # Handle launchPermission attributes:
       rootelement.elements.each("launchPermission/item/*") do |element|
Index: lib/EC2.rb
===================================================================
--- lib/EC2.rb	(revision 7)
+++ lib/EC2.rb	(working copy)
@@ -24,8 +24,6 @@
 require 'rexml/document'
 require 'time'
 
-include REXML
-
 # Require any lib files that we have bundled with this Ruby Gem in the lib/EC2 directory.
 # Parts of the EC2 module and AWSAuthConnection class are broken out into separate
 # files for maintainability and are organized by the functional groupings defined 
